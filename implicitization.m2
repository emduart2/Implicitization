
newPackage(
        "implicitization",
        Version => "0.1", 
        Date => "June 5, 2015",
        Authors => {{Name => "Eliana Duarte", Email => "emduart2@illinois.edu", HomePage => "http://www.math.uiuc.edu/~emduart2/"}},
        Headline => "A package for computing implicit equations of rational maps",
        DebuggingMode => true
        )

export {
    "firstFunction",
    "bigradedHilbertF",
    "genericMap",
    "kpoints"
    }

firstFunction = method(TypicalValue => String)
firstFunction ZZ := String => n -> if n == 1 then "Hello World!" else "implicitization"

-----------------------------------------------
genericMap = method()
-----------------------------------------------
--Documentation
--Input: An ideal I in R=k[s,t,u,v] and a
--       bidegree (a,b).
--Output: A generic choice of 4 bihomogeneous 
--       forms in I of bidegree (a,b) 
--Comments: You can use this to define generic
--       maps into projective 3 space.
----------------------------------------------
genericMap(ZZ,ZZ,Ideal):= Ideal => (i,j,I)->(
    R:= ring I;
    M:= super basis({i,j},I);
    n:= numgens source M;
    gnerators:= random(R^4,R^n)*transpose M;
    test:=ideal(gnerators);
    return test;
) 
----------------------------------------------

----------------------------------------------
kpoints = method()
----------------------------------------------
--Documentation
--Input: A nonnegative integer k.
--Output: The ideal of k generic points in P^1xP^1.
--        That is the ideal of a diagonal set
--        of points lying on a complete intersection
--        of k^2 points.
--Comments: You can use this code to easily
--         generate ideals that determine generic
--         points in P^1xP^1. The way the code works
--         is that it generates  k generic linear forms
--         in the variables s,t and k generic linear forms
--         in the variables u,v. Then it pairs them up
--         to define the ideal of a point. Finally it intersects
--         the ideal of all the points. 
----------------------------------------------
kpoints(ZZ,Ideal):=Ideal => (k,J)->(
    R:= ring J;
    i:=0;
    lst:={};
    while i<k
    do(
    M:=random(R^1,R^2);
    forms:=transpose(super basis({1,0},R));
    Lp:=M*forms;
    M:=random(R^1,R^2);
    forms:=transpose(super basis({0,1},R));
    Lq:=M*forms;
    testo:=ideal(Lp,Lq);
    lst:=lst|{testo};
    i:=i+1;
    );
   I:=lst_0;
   j:=1;
   while j<k
   do(
   I:=intersect(I,lst_j);
   j:=j+1;
   );
   return I;
)


--------**-----**------**--------------------------
bigradedHilbertF = method()
----------------------------------------------
--Documentation
--Input:
--Output:
--Comments:



bigradedHilbertF(ZZ,ZZ,Ideal):= ZZ => (i,j,I)->(
    R:=ring I;
    M:=super basis({i,j},I);
    N:=super basis({i,j},R);
    m:=numgens source M;
    n:=numgens source N;
    hfq:=n-m;
    return hfq;
)


beginDocumentation()

doc ///
    Key
        genericMap
    Headline
        Create a generic map to P^3 using the ideal I
    Usage
        U=genericMap(i,j,I)
    Inputs
        i:ZZ
	    i= first entry of bidegree
	j:ZZ
	    j= second entry of bidegree
	I:Ideal
	    I= graded bihomogeneous ideal
    Outputs
        U:Ideal
	    U= ideal generated by 4 bihomogenous forms of degree (i,j)
    Description
        Text
	    For a given ideal I in the coordinate ring of P^1xP^1, obtain
	    a generic choice of 4 forms in I of bidegree (i,j).
	Example
	    R=ZZ/31991[s,t,u,v, Degrees=>{{1,0},{1,0},{0,1},{0,1}}];
	    I=ideal(s,u); 
	    U=genericMap(3,1,I);
	    gens U;
	Text
	    The ideal I determines a point in P^1xP^1, therefore 
	    the map to P^3 determined by U will have a basepoint.
///


doc ///
    Key
        bigradedHilbertF
    Headline
        compute bigraded hilbert function
    Usage
        d=bigradedHilbertF(i,j,I)
    Inputs
        i:ZZ
	    i= first entry of bidegree
	j:ZZ
	    j= second entry of bidegree
	I:Ideal
	    I= graded bihomogeneous ideal
    Outputs
        d:ZZ
	    d= dimension of the bigraded piece i,j
    Description
        Text
	    Given a bidegree (i,j) and a graded bihomogeneous ideal compute the dimension
	    of the vector space at degree (i,j)
///

TEST ///
    assert ( firstFunction 2 == "D'oh!" )
///

end

You can write anything you want down here.  I like to keep examples
as Iâ€™m developing here.  Clean it up before submitting for
publication.  If you don't want to do that, you can omit the "end"
above.